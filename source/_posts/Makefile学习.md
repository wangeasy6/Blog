---
title: Makefile学习
date: 2018-11-24 10:56:46
toc: true
categories:
  - tech
tags:
  - 待续
---

在学习 BootLoader 和 Linux 的时候，make 都是他们默认的自动化编译工具，所以makefile是对理解系统架构、了解编译流程绕不开的槛。
对make工具的掌握也间接决定了构建大型项目的能力。

<!--more-->

### 基本概念

一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Make 工具能够使用一行命令来完成“自动化编译”。

make是一个命令工具，它解释Makefile 中的指令。

Makefile 文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建哪些库文件以及如何创建这些库文件、如何最后产生我们想要的可执行文件。

Makefile 有自己的书写格式、关键字、函数。像C 语言有自己的格式、关键字和函数一样。而且在Makefile 中可以使用系统shell所提供的任何命令来完成想要的工作。

### 基本形式

每一项 Makefile 都是由 目标、依赖、命令 组成：

```
target: prerequisites
	command
```

依赖项可以展开为另一个拥有依赖的目标，以此递归地构建整个项目，生成目标文件。



### 赋值

| 符号    | 含义                                                         |
| ------- | ------------------------------------------------------------ |
| **=**   | 用 "=" 定义的变量是递归展开的变量                            |
| **:=**  | 用 ": =" 或 ": =" 定义的变量只是展开的变量                   |
| **::=** | 在GNU make 中，同":="，2012年被添加到POSIX标准，之前的版本不支持 |
| **?=**  | 用 "?=" 定义的变量仅在尚未设置变量的情况下将其设置为值       |
| **!=**  | shell 赋值运算符 '! = ' 可用于执行 shell 脚本并为其输出设置变量。此运算符首先计算右侧, 然后将该结果传递给用于执行的 shell |
| **+=**  | 向已定义的变量的值添加文本                                   |



### 特殊符号

| 符号             | 含义                                    |
| ---------------- | --------------------------------------- |
| $@               | 目标项，例： `cc -c $(CFLAGS) $< -o $@` |
| $<               | 第一个依赖项                            |
| $^               | 所有依赖项                              |
| $+               | 也是所有依赖项，但是这个不去除重复的项  |
| $%               | 仅当目标是函数库文件中，                |
| $*               | 这个变量表示目标模式中“%”及其之前的部分 |
| $? | 表示比目标还要新的依赖文件列表 |
| $(@D) / $(@F) | $@ 中的目录+文件名部分                  |
| $(\*D) / $(\*F) | $* 中的目录+文件名部分                   |
| $(%D) / $(%F) | $% 中的目录+文件名部分                   |
| $(<D) / $(<F) | $< 中的目录+文件名部分                   |
| $(^D) / $(^F) | $^ 中的目录+文件名部分                   |
| $(+D) / $(\+F) | $+ 中的目录+文件名部分                   |
| $(?D) / $(?F) | $? 中的目录+文件名部分                   |



### 常用函数

| 示例                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| $(wildcard *.cpp)            | 在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。此时则使用函数 wildcard |
| $(patsubst %c, %o, $(SRC_C)) | 替换函数，把 $SRC_C中每一项的c换为 o                         |
| $(SRC_C:%.c=%.o)             | 效果同上                                                     |
| $(notdir $(src))             | 去除路径，去除变量中的文件路径部分                           |



### 递归make子文件夹

`$(MAKE) -C subdir`

其等价于：

`cd subdir && $(MAKE)`



### make读取命令行参数
使用方法：
例：使用 O= 来指定输出目录
`make O=/tmp/build`

代码实现：
```
ifdef O
ifeq ("$(origin O)", "command line")
BUILD_DIR := $(O)
endif
endif
```

代码分析：
真正起作用的是 BUILD_DIR := $(O)
${O} 就会把输入里 O= 后面的值取出

ifdef O，检测变量O是否为空
${origin O}，使用origin函数，得到变量的出处
ifeq ("$(origin O)", "command line")，检测是否是从命令行输入定义

