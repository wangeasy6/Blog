---
title: 串口文件传输协议
toc: true
categories:
  - Technology
---

使用串口升级设备时，需要使用串口来发送一个比较大的文件，自我实现的一个类YMODEM协议存在缺陷，速度慢（在115200bps下，1M大概需要1min），上位机有时候会收不到ACK，设备又没有做超时，这个时候设备就会停在接收文件。

所以现在补补课，研究一下通用的串口文件传输协议，看看怎么做才能既稳定又快速。

<!--more-->

<br/>

## 概览

常用的串口文件传输协议有3种：XMODEM、 YMODEM、 ZMODEM。以下是对X/Y/ZModem协议及其变种的简述。

**XMODEM**

最初的 XMODEM 协议使用128字节的数据包和简单的“校验和”错误检测方法。

后来的增强，XMODEM-CRC，使用更安全的循环冗余校验（CRC）方法进行错误检测。

Xmodem协议总是首先尝试使用 CRC 。如果发送方不确认 CRC 请求，则接收方切换到校验和模式并继续其传输请求。

**XMODEM/CRC**

XMODEM/CRC 将 XMODEM 的1字节校验和替换为2字节循环冗余校验（CRC-16），提供了更强的错误检测保护。

**XMODEM-1k**

XMODEM-1k 是指具有1024字节数据块的 XMODEM/CRC 协议。

**YMODEM**

YMODEM 是指 XMODEM/CRC-1K（包含可选的 1KB 数据包），且具有批处理文件传输功能。

**YMODEM-g**

YMODEM-g 是不包含数据返回的 YMODEM协议，用于带有数据校准的传输链路中。

**ZMODEM**

ZMODEM 在一个新的协议中使用了熟悉的XMODEM/CRC和YMODEM技术，该协议提供了适合现代数据通信的可靠性、吞吐量、文件管理和用户便利性。

ZMODEM 在发送每个块之后不等待肯定确认，而是快速连续地发送块。如果 ZMODEM 传输由于任何原因被取消或中断，那么传输可以稍后恢复，并且不需要重新发送先前传输的信息。

<br/>

## XMODEM

XMODEM 是一种半双工通信协议。XMODEM 传输是用户驱动的。

首先，用户将在发送方的系统上导航，选择想要的文件；然后发送命令请求发送方系统开始发送该文件；命令发出后，就会开启本机软件进行接收（如果发送了请求命令，而又一直没有收到数据，XMODEM 规定最多可以等待90s）。

然后，XMODEM 将原始数据分解成一系列发送到接收方的数据包(128字节)，同时附加的信息允许接收方确定数据包是否被正确接收。

该数据包的前缀是一个简单的3字节头，其中包含一个 <SHO> 字符，一个0-255的块号，以及一个“逆”块号（255减去块号）。对于第一个发送的块，块编号从1开始，而不是0。

标头后面跟着128个字节的数据，然后是一个单字节的校验和。

校验和是模256数据包中所有字节的和。除了结果中8个最低有效位之外，所有模除都可以轻松计算出来，或者在一台8位机器上交替使用，忽略自动产生相同效果的算术溢出。通过这种方式，校验和被限制为八位数量。例如，如果这种校验和方法用于一个只包含两个字节值130和130的微小数据包，这些代码的总和为260，结果校验和为4。

因此，完整的数据包有132字节长，包含128字节的有效载荷数据，总的通道效率约为97% 。

文件一次传输一个数据包。当接收时，包的校验和由接收者计算并与包末端从发送者接收的校验和进行比较。如果两者匹配，接收方将向发送方发送一个 <ACK> 消息，然后发送方按顺序发送下一个数据包。如果校验和出了问题，接收方就会发送 <NAK> 。如果收到一个 <NAK> ，发送方将重新发送数据包，并继续尝试几次，通常是十次，然后中止传输。

如果接收方在10秒内没有收到有效的数据包，那么也会发送一个 <NAK> 。

为了检查错误，还以一种简单的方式检查了块编号。成功接收数据包后，下一个数据包应该有一个更高的数字。如果它反而收到相同的块号，这被认为不严重，这意味着 <ACK> 没有被发送方收到，然后重新发送数据包。任何其他数据包号码表示数据包丢失。



**标识符号定义**

以下定义了用于协议流控制。

| 符号 | 描述                               | 值   |
| ---- | ---------------------------------- | ---- |
| SOH  | 帧头                               | 0x01 |
| EOT  | 传输结束标识                       | 0x04 |
| ACK  | 确认无误                           | 0x06 |
| NAK  | 确认有误                           | 0x15 |
| ETB  | 传输阻塞结束 (回到 Amulet OS 模式) | 0x17 |
| CAN  | 取消传输（强制接收器开始发送C）    | 0x18 |
| C    | ASCII “C”                          | 0x43 |

**流程图**

![XMODEM流程图.png](/resources/uart_file_transfer_protocol/XMODEM流程图.png)

**不足**

1. 由于使用了一个简单的校验和进行错误校正，如果两个比特被反转，一个错误的文件可能被当成正确的文件
2. 小的数据包大小和等待 ACK 或 NAK 的要求导致在高速链路或具有显著延迟的链路上性能降低
3. 由于传输不包含文件的详细信息，每个文件都必须手动启动，这在传输许多小文件时可能是一件繁琐的事情
4. 一旦启动，没有定义中止传输的方法（发送端可以通过90s不发送中止，接收端可以通过10次NAK中止，但是花费时间非常长）
5. 不支持断点续传

<br/>

## YMODEM

YMODEM 基于 XMODEM-1K，再结合了其他 XMODEM 扩展协议的特性。

1. 与 XMODEM-CRC 一样，YMODEM 用16位校验循环冗余校验(CRC)替换了8位校验和，但是将其作为默认的修正形式而不是可选的。
2. 在 TeLink 中，它添加了发送文件名和大小的“ block 0”头，从而允许批量传输(单个会话中的多个文件) ，并消除了在文件末尾添加填充的需要。
3. 最后，YMODEM 允许块大小从最初的128字节数据增加到1024，就像 XMODEM-1k 一样，这大大提高了速度更快的调制解调器的吞吐量。
4. 接收方将尝试通过发送初始 c 而不是 NAK 来触发传输。

16位的CRC 不仅对数据包中的数据进行编码，而且还对数据包的位置进行编码，这使它能够注意到校验和可能会错过的位置替换错误。

XMODEM-CRC 被设计为与 XMODEM 后向兼容。为此，接收方发送一个 c (大写 c)字符代替 < nak > 开始传输。如果发送方发送了一个数据包作为响应，则假定发送方“知道”XMODEM-CRC，而接收方继续发送 c。如果没有数据包即将到来，接收方假定发送方不知道协议，并发送一个 < nak > 开始“传统的”XMODEM 传输。

不幸的是，这种对向下兼容的尝试也有不利的一面。由于初始 c 字符有可能丢失或损坏，如果第一次触发传输的尝试失败，就不能假定接收方不支持 XMODEM-CRC。因此，接收器尝试用 c 开始传输三次，每次尝试之间等待三秒钟。这意味着，如果用户在试图与任何 XMODEM 通话时选择了 XMODEM-CRC，那么在传输开始之前可能会有10秒的延迟。

**示例**

```
SENDER                                           RECEIVER

                                         <--        C
STX 01 FE Data[1024] CRC CRC            -->
                                         <--        ACK
STX 02 FD Data[1024] CRC CRC            -->
                                         <--        ACK
STX 03 FC Data[1000] CPMEOF[24] CRC CRC -->
                                         <--        ACK
EOT                                     -->
                                         <--        ACK
```

CRC，C语言实现：

```c
int calcrc(char *ptr, int count)
{
    int  crc;
    char i;
    crc = 0;
    while (--count >= 0)
    {
        crc = crc ^ (int) *ptr++ << 8;
        i = 8;
        do
        {
            if (crc & 0x8000)
                crc = crc << 1 ^ 0x1021;
            else
                crc = crc << 1;
        } while(--i);
    }
    return (crc);
}
```

<br/>

## ZMODEM



## 实验对比

同一份1M大小的文件，分别通过X、Y、ZModem协议发送，看看成功率、传输速度。





<br/>

## 参考

* [XMODEM|wikipedia](https://en.wikipedia.org/wiki/XMODEM)
* [YMODEM|wikipedia](https://en.wikipedia.org/wiki/YMODEM)
* [ZMODEM|wikipedia](https://en.wikipedia.org/wiki/ZMODEM)
* [XModem Protocol with CRC | MIT](http://web.mit.edu/6.115/www/amulet/xmodem.htm)
* [XMODEM / YMODEM Protocol Reference by Chuck Forsberg (document reformatted October 14, 1988) ](http://pauillac.inria.fr/~doligez/zmodem/ymodem.txt)
