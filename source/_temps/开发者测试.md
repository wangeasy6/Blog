---
title: 开发者测试
tags:
---

作为一个开发者，大部分时候我们在进行开发的时候就已经能够遇见一部分BUG了，并且进行了一部分的防御编程，但是经常自己也能感觉应该还有些问题。

这个时候我们可以选择自己继续做白盒测试，或者给测试人员做黑盒测试。一般来说，两种测试测出的BUG不会完全重叠，黑盒测试对于很多边界值是不知道的，大多停留在业务层面，而白盒测试则因为开发者盲区而测不干净，当然也有业务理解不到位的情况。

但是作为一个开发者，防御编程总是必不可少的，而防御编程能做到多好则基于自我的测试，这对于写接口或者子功能来说就更重要了。所以测试，应该是一个开发必不可少的技能，尤其是黑盒测试不会管的单元测试之类的测试。

而且，Google、Microsoft等大公司都趋向于工程师自己完成测试，Google的SET的主要工作是提供测试工具和框架。

<!--more-->

<br/>

## 测试类型

* **单元测试**：是对一个完整的类、接口、子程序单独进行测试。
* **集成测试**：是对两个或更多的类、包或者子系统进行联合测试。
* **回归测试**：是指Bug被开发人员修改后，重复执行以前的测试用例。
* **系统测试**：是在用户环境的配置下运行整个软件。以测试安全、性能、资源消耗、时序方面的问题，以及其他无法在低级集成上测试的问题。
* **性能测试**：是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。
* **负载测试**：确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。
* **压力测试**：是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。

## CSharp 代码覆盖率测试



## CSharp UI自动化测试



## Python 单元测试

### unittest

参考：https://docs.python.org/zh-cn/3.7/library/unittest.html

```python
import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
```

运行，输出：

```
...
----------------------------------------------------------------------
Ran 3 tests in 0.003s

OK
```

说明：

继承 [`unittest.TestCase`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.TestCase) 就创建了一个测试样例。

类的方法都以 `test` 开头，这个命名约定告诉测试运行者类的哪些方法表示测试。

调用 [`assertEqual()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.TestCase.assertEqual) 来检查预期的输出； 调用 [`assertTrue()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.TestCase.assertTrue) 或 [`assertFalse()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.TestCase.assertFalse) 来验证一个条件；调用 [`assertRaises()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.TestCase.assertRaises) 来验证抛出了一个特定的异常。使用这些方法而不是 [`assert`](https://docs.python.org/zh-cn/3.7/reference/simple_stmts.html#assert) 语句是为了让测试运行者能聚合所有的测试结果并产生结果报告。

最后的代码块中，演示了运行测试的一个简单的方法。 [`unittest.main()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.main) 提供了一个测试脚本的命令行接口。当在命令行运行该测试脚本，上文的脚本生成如上格式的输出。

在调用测试脚本时添加 `-v` 参数使 [`unittest.main()`](https://docs.python.org/zh-cn/3.7/library/unittest.html#unittest.main) 显示更为详细的信息，生成如以下形式的输出:

```
test_isupper (__main__.TestStringMethods) ... ok
test_split (__main__.TestStringMethods) ... ok
test_upper (__main__.TestStringMethods) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
```

unittest 模块可以通过命令行运行文件、模块、类和独立测试方法的测试:

```shell
python -m unittest tests/test_something.py
python -m unittest test_module1 test_module2
python -m unittest test_module.TestClass
python -m unittest test_module.TestClass.test_method
python -m unittest -v test_module
python -m unittest -h
```



<br/>

## PyQT UI 自动化测试



## pytest



## C 单元测试

### CUnit

### CuTest

### cmocka

<br/>